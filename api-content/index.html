{"posts":[{"title":"NOIP 前杂题选做","content":"DP 蓝 CF922E 令 fi,jf_{i,j}fi,j​ 表示到了第 iii 棵树， jjj 只鸟能保存的最大魔法。这样我们可以知道所有信息。复杂度参考树上背包。 CF1628D fi,jf_{i,j}fi,j​ 表示前 iii 轮用了 jjj 次加法，用博弈论的思想不难得出转移式。由于转移式形如组合数，所以直接打表观察后组合数直接做。 CF1614D 令 fif_ifi​ 表示此时 gcdgcdgcd 为 iii 的最大答案。显然如果 gcdgcdgcd 为 iii，我们可以让所有剩下能整除 iii 的数先加入一定不劣。我们再记录 cnticnt_icnti​ 表示 iii 能被多少数整除。然后我们就能枚举 iii 的因子转移算贡献了。 显然我们不必枚举所有因子，我们只需要枚举 iii 的质因子 ppp，然后向 ip\\frac{i}{p}pi​ 转移即可。 cnticnt_icnti​ 可以 O(mlog⁡m)O(m\\log m)O(mlogm) 调和级数做。 构造 CF925C 有点难。我还是没有思维。 也就是说求 bib_ibi​ 的顺序，使得其前缀异或和严格递增。 首先一个数出现三次及以上必定无解。因为出现两次相当没出现，那就不可能递增。 我们维护一个 SSS 表示前缀异或和。考虑我们加入什么数才能递增。显然加入的这个数的最高位，SSS 在该位必然为零。 根据这个性质，我们有：如果 SSS 在某数字最高位为 000，此时我们再加入这个数字必然递增。 那么难点就是怎么 SSS 在某数字最高位为 111 时，把这个元素插入。 显然必须要先插入任意其他长度，且那一位为一。 然后我们考虑每次插入数，找到 SSS 第一位为零的位置，然后插入数。这样居然过了！ 其实很好理解：插入一个位数更高的数对于插入低位只有好处，没有坏处，如果插入的数低位的某一位为 111，如果 SSS 的这一位也是 111，那么刚好给这一位清零，否则根据前提，已经没有长度为这一位的数还没插入了，肯定没有影响。如果插入的数那一位为 000，那自然没有影响。 ARC136C 序列是好做的。 最开始想断环为链，枚举一条边断开，并维护答案，发现不太对，因为操作可能每一条边都会跨过。 我们可以先找到跨过 n→1n\\rightarrow 1n→1 这条边的的操作，再当成链去做。 ","link":"https://ganytx.github.io/post/noip-qian-za-ti-xuan-zuo/"},{"title":"数学乱记","content":"杜教筛 问题是要求数论函数的和 S(n)=∑i=1nf(i)S(n)=\\sum^n_{i=1}f(i)S(n)=∑i=1n​f(i)。 先对卷积求和进行研究。 ∑i=1n(f∗g)(i)\\sum^n_{i=1}(f*g)(i) i=1∑n​(f∗g)(i) 这跟 S(n)S(n)S(n) 有什么关系？变换一下。 ∑i=1n∑d∣ig(d)f(id)=∑d=1ng(d)∑t=1⌊nd⌋f(t)=∑d=1ng(d)S(⌊nd⌋)\\sum^n_{i=1}\\sum_{d\\mid i}g(d)f(\\frac{i}{d})=\\sum^n_{d=1}g(d)\\sum^{\\lfloor\\frac{n}{d}\\rfloor }_{t=1}f(t)=\\sum_{d=1}^ng(d)S(\\lfloor\\frac{n}{d}\\rfloor) i=1∑n​d∣i∑​g(d)f(di​)=d=1∑n​g(d)t=1∑⌊dn​⌋​f(t)=d=1∑n​g(d)S(⌊dn​⌋) 将其差分一下，我们就有： S(n)=g(1)S(n)=∑i=1n(f∗g)(i)−∑d=2ng(d)S(⌊nd⌋)S(n)=g(1)S(n)=\\sum^n_{i=1}(f*g)(i)-\\sum_{d=2}^ng(d)S(\\lfloor\\frac{n}{d}\\rfloor) S(n)=g(1)S(n)=i=1∑n​(f∗g)(i)−d=2∑n​g(d)S(⌊dn​⌋) 如果找的 ggg 得当，我们就能很方便的递归加整除分块解决这个问题了。 我们有 φ∗1=id\\varphi*1=idφ∗1=id 和 μ∗1=ε\\mu*1=\\varepsilonμ∗1=ε。 我觉得这个东西有点像反演。 FWT 快速求形如 ck=∑i⊕j=kaibic_k=\\sum_{i\\oplus j=k}a_ib_ick​=∑i⊕j=k​ai​bi​，其中 ⊕\\oplus⊕ 可以是或，与，异或。 或： 令 fwt(a)i=∑k∣i=iakfwt(a)_i=\\sum_{k|i=i}a_kfwt(a)i​=∑k∣i=i​ak​，即 kkk 是 iii 的子集。 我们有： fwt(c)i=fwt(a)ifwt(b)ifwt(c)_i=fwt(a)_ifwt(b)_i fwt(c)i​=fwt(a)i​fwt(b)i​ 考虑 k1∣i=i,k2∣i=ik_1|i=i,k_2|i=ik1​∣i=i,k2​∣i=i，那么 (k1∣k2)∣i=i(k_1|k_2)|i=i(k1​∣k2​)∣i=i。 如何求 fwt(a)fwt(a)fwt(a)？直接类似 fftfftfft 递归求即可。 设 aaa 长度为 2n2^n2n。令 aaa 的前 2n−12^{n-1}2n−1 项组成 a0a_0a0​，后 2n−12^{n-1}2n−1 项组成为 a1a_1a1​。mergemergemerge 表示拼接，+++ 表示代数相加。 我们有 fwt(a)=merge(fwt(a0),fwt(a0)+fwt(a1))fwt(a)=merge(fwt(a_0),fwt(a_0)+fwt(a_1))fwt(a)=merge(fwt(a0​),fwt(a0​)+fwt(a1​))。 证明显然。 关于 ifwtifwtifwt，a=merge(a0,ifwt(fwt(a)1−fwt(a)0))a=merge(a_0,ifwt(fwt(a)_1-fwt(a)_0))a=merge(a0​,ifwt(fwt(a)1​−fwt(a)0​)) 与 fwt(a)i=∑k&amp;i=iakfwt(a)_i=\\sum_{k\\&amp; i=i}a_kfwt(a)i​=∑k&amp;i=i​ak​ fwt(a)=merge(fwt(a0)+fwt(a1),fwt(a0))fwt(a)=merge(fwt(a_0)+fwt(a_1),fwt(a_0))fwt(a)=merge(fwt(a0​)+fwt(a1​),fwt(a0​)) 异或 异或不满足 k1⊕i=i,k2⊕i=i⟹(k1⊕k2)⊕i=ik_1 \\oplus i=i,k_2 \\oplus i=i\\Longrightarrow (k_1 \\oplus k_2) \\oplus i=ik1​⊕i=i,k2​⊕i=i⟹(k1​⊕k2​)⊕i=i。 FMT 或的 FMT 就是在做高维前缀和。先对第一维做前缀和，第二维做前缀和...一直做到第 kkk 维，复杂度 O(nkk)O(n^kk)O(nkk)。 与的 FMT 就是在做高维差分。 Dirichlet 前缀和 给 aaa，求 bk=∑i∣kaib_k=\\sum_{i|k}a_ibk​=∑i∣k​ai​。 考虑将 iii 质因数分解：i=∏pikii=\\prod p_i^{k_i}i=∏piki​​。将 kik_iki​ 看成空间上第 iii 维，发现做 Dirichlet 前缀和的时候相当于在做高维前缀和。 做法和 FMT 一样。 枚举质数，先做 222 这一维度的前缀和，在做 3,5,7...3,5,7...3,5,7...。 复杂度：O(∑⌊npi⌋)=O(nlog⁡log⁡n)O(\\sum\\lfloor\\frac n {p_i}\\rfloor)=O(n\\log\\log n)O(∑⌊pi​n​⌋)=O(nloglogn)。 Dilworth 定理 部分序理论前置知识 传递闭包： 对于集合 SSS 定义二元关系 RRR 和 TTT。如果 TTT 满足：∀x,y∈S,xTy⟶∃a0=x,a1,a2...ak=y\\forall x,y\\in S,xTy\\longrightarrow \\exists a_0=x,a_1,a_2...a_k=y∀x,y∈S,xTy⟶∃a0​=x,a1​,a2​...ak​=y 使得 a0Ra1,a1Ra2...an−1Rana_0Ra_1,a_1Ra_2...a_{n-1}Ra_na0​Ra1​,a1​Ra2​...an−1​Ran​，那么 TTT 是 RRR 的传递闭包。 例如对于一个图，两个点联通意味着存在一条路径，而这条路径上相邻的点有边，那么联通关系就是相连关系的传递闭包。 偏序： 满足自反性，反对称性，传递性的二元关系是非严格偏序关系，记作 $\\preceq $。满足反自反性，非对称性，传递性的二元关系是严格偏序关系，记作 $\\prec $。 对于偏序集 (A,R)(A,R)(A,R)： 链：A′⊆AA&#x27;\\subseteq AA′⊆A 且 ∀x,y∈A′\\forall x,y\\in A&#x27;∀x,y∈A′ 满足 xRyxRyxRy 或 yRxyRxyRx。 反链：A′⊆AA&#x27;\\subseteq AA′⊆A 且 ∀x,y∈A′\\forall x,y\\in A&#x27;∀x,y∈A′ 都不满足 xRyxRyxRy 或 yRxyRxyRx。 链覆盖：将集合划分成若干条链，大小为链的数量。 可以将偏序集看成是一个 DAG，R 关系可以看成是一条有向边。 Dilworth's Theorem 定理：一个偏序集的最大反链大小等于其最小链覆盖。 证明：用归纳法，假设我们已经证出元素少的情况，考虑怎么证明元素更多的情况。 首先最小链覆盖小于反链是易证矛盾的，下面证最小链覆盖不会大于反链。 考虑令 SSS 的反链为 AAA。考虑用 AAA 将 SSS 划分成两个集合。 S+={x∈S∣∃a∈A,a⪯x}S^+=\\{x\\in S|\\exists a\\in A,a\\preceq x\\} S+={x∈S∣∃a∈A,a⪯x} S−={x∈S∣∃a∈A,x⪯a}S^-=\\{x\\in S|\\exists a\\in A,x\\preceq a\\} S−={x∈S∣∃a∈A,x⪯a} 如果 S+=SS^+=SS+=S 或 S−=SS^-=SS−=S，那么说明 AAA 中每个元素都是 SSS 的某条链的最大元或最小元。我们随便选一个长度大于二的链，删掉该链的最大元和最小元，此时反链大小恰好减少一，根据归纳法，最小链覆盖等于此时反链大小，此时再加入最大元和最小元，这两个元素又能构成新的链，依然恰好相等。得证。 否则，根据归纳法，由于 S+S^+S+ 和 S−S^-S− 交为 AAA，因此这两个集合的最小链覆盖数不变，考虑枚举 AAA 中的元素作为中间点，来将 S+S^+S+ 和 S−S^-S− 的链拼起来，发现最小链覆盖数量依旧不变，该定理得证。 十二重计数 球不同，盒子不同：mnm^nmn。 球不同，盒子不同，每个盒子至多一个球：m!n!\\frac{m!}{n!}n!m!​ 球不同，盒子不同，每个盒子至少一个球： ","link":"https://ganytx.github.io/post/shu-xue-luan-ji/"},{"title":"最小斯坦纳树","content":"考虑令 fi,Sf_{i,S}fi,S​ 表示以 iii 为根的生成树，这棵树包含了 SSS 里的关键点。 两种转移： fi,S⟵fi,T+fi,S−Tf_{i,S}\\longleftarrow f_{i,T}+f_{i,S-T}fi,S​⟵fi,T​+fi,S−T​ fi,S⟵fj,S+w(i,j)f_{i,S}\\longleftarrow f_{j,S}+w(i,j)fi,S​⟵fj,S​+w(i,j) 第一个转移相当于将 iii 的两棵子树合并，第二个转移相当于以 jjj 为根的生成树向 iii 扩展。 由于第二个转移没有明确的方向，因此跑一个最短路来转移。 复杂度：O(3kn+2kmlog⁡m)O(3^kn+2^km\\log m)O(3kn+2kmlogm)。 考虑询问加入一个新的关键点后的最小斯坦纳树。这个东西也是十分简单的，就是 f[i][U]f[i][U]f[i][U]。 ","link":"https://ganytx.github.io/post/zui-xiao-si-tan-na-shu/"},{"title":"具体数学笔记","content":"本文为笔者早期学习具体数学时的笔记，未完结（可能再也不更新了） 和式 和式的几种基本处理手法 扰动法 几个例子。 例一：Sn=∑k=0naxkS_n=\\sum_{k=0}^nax^kSn​=∑k=0n​axk xSn=∑k=0naxk+axn+1−axS_n=\\sum_{k=0}^nax^k+ax^{n+1}-a xSn​=k=0∑n​axk+axn+1−a xSn−Sn=axn+1−axS_n-S_n=ax^{n+1}-a xSn​−Sn​=axn+1−a Sn=axn+1−ax−1,x≠1S_n=\\frac{ax^{n+1}-a}{x-1},x\\ne 1 Sn​=x−1axn+1−a​,x​=1 例二：Sn=∑k=0nkxkS_n=\\sum_{k=0}^nkx^kSn​=∑k=0n​kxk xSn=∑k=1n+1(k−1)xkxS_n=\\sum_{k=1}^{n+1}(k-1)x^k xSn​=k=1∑n+1​(k−1)xk xSn−Sn=∑k=1n+1(k−1)xk−∑k=1nkxk=nxn+1−∑k=1nxkxS_n-S_n=\\sum_{k=1}^{n+1}(k-1)x^k-\\sum_{k=1}^nkx^k=nx^{n+1}-\\sum_{k=1}^nx^k xSn​−Sn​=k=1∑n+1​(k−1)xk−k=1∑n​kxk=nxn+1−k=1∑n​xk Sn=nxn+1−∑k=1nxkx−1=nxn+2−(n+1)xn+1+x(x−1)2,x≠1S_n=\\frac{nx^{n+1}-\\sum_{k=1}^nx^k}{x-1}=\\frac{nx^{n+2}-(n+1)x^{n+1}+x}{(x-1)^2},x\\ne1 Sn​=x−1nxn+1−∑k=1n​xk​=(x−1)2nxn+2−(n+1)xn+1+x​,x​=1 例三：Sn=∑i=1ni2S_n=\\sum_{i=1}^ni^2Sn​=∑i=1n​i2 ∑i=1n(i+1)3−∑i=1ni3=(n+1)3−1\\sum_{i=1}^n(i+1)^3-\\sum_{i=1}^ni^3=(n+1)^3-1 i=1∑n​(i+1)3−i=1∑n​i3=(n+1)3−1 ∑i=1n(i3+3i2+3i+1)−∑i=1ni3=(n+1)3−1\\sum_{i=1}^n(i^3+3i^2+3i+1)-\\sum_{i=1}^ni^3=(n+1)^3-1 i=1∑n​(i3+3i2+3i+1)−i=1∑n​i3=(n+1)3−1 3∑i=1ni2+3∑i=1ni+∑i=1n1=(n+1)3−13\\sum_{i=1}^ni^2+3\\sum_{i=1}^ni+\\sum_{i=1}^n1=(n+1)^3-1 3i=1∑n​i2+3i=1∑n​i+i=1∑n​1=(n+1)3−1 3∑i=1ni2+3n(n+1)2+n=(n+1)3−13\\sum_{i=1}^ni^2+\\frac{3n(n+1)}{2}+n=(n+1)^3-1 3i=1∑n​i2+23n(n+1)​+n=(n+1)3−1 ∑i=1ni2=(n+1)3−3n(n+1)2−n−13=n(n+1)(2n+1)6\\sum_{i=1}^ni^2=\\frac{(n+1)^3-\\frac{3n(n+1)}{2}-n-1}{3}=\\frac{n(n+1)(2n+1)}{6} i=1∑n​i2=3(n+1)3−23n(n+1)​−n−1​=6n(n+1)(2n+1)​ 可用同样方法推广至 kkk 次方 令 Snk=∑i=1nikS^k_n=\\sum_{i=1}^ni^kSnk​=∑i=1n​ik 则 Snk=(n+1)k+1−∑i=0k−1(k+1i)Sni−1k+1S^k_n=\\frac{(n+1)^{k+1}-\\sum^{k-1}_{i=0}\\binom{k+1}{i}S^i_n-1}{k+1} Snk​=k+1(n+1)k+1−∑i=0k−1​(ik+1​)Sni​−1​ 交换求和顺序 [1≤i≤n][i≤j≤n]=[1≤i≤j≤n]=[1≤j≤n][1≤i≤j][1\\le i\\le n][i\\le j\\le n]=[1\\le i\\le j\\le n]=[1\\le j\\le n][1\\le i \\le j][1≤i≤n][i≤j≤n]=[1≤i≤j≤n]=[1≤j≤n][1≤i≤j] 由此可得，∑i=1n∑j=inai,j=∑j=1n∑i=1jai,j\\sum^n_{i=1}\\sum^n_{j=i}a_{i,j}=\\sum^n_{j=1}\\sum^j_{i=1}a_{i,j}∑i=1n​∑j=in​ai,j​=∑j=1n​∑i=1j​ai,j​ 替换指标变量 例如：Sn=∑k=1n∑i=1k−11k−iS_n=\\sum^n_{k=1}\\sum^{k-1}_{i=1}\\frac{1}{k-i}Sn​=∑k=1n​∑i=1k−1​k−i1​ Sn=∑k=1n∑i=1n−k1k=∑k=1nn−kkS_n=\\sum^n_{k=1}\\sum^{n-k}_{i=1}\\frac{1}{k}=\\sum^n_{k=1}\\frac{n-k}{k} Sn​=k=1∑n​i=1∑n−k​k1​=k=1∑n​kn−k​ 裂项相消法 例如：∑k=1n1k(k+1)\\sum^n_{k=1}\\frac{1}{k(k+1)}∑k=1n​k(k+1)1​。 ∑k=1n1k(k+1)=∑k=1n1k−1k+1=11−12+12−13+...−1n+1=1−1n+1\\sum^n_{k=1}\\frac{1}{k(k+1)}=\\sum^n_{k=1}\\frac{1}{k}-\\frac{1}{k+1}=\\frac{1}{1}-\\frac{1}{2}+\\frac{1}{2}-\\frac{1}{3}+...-\\frac{1}{n+1}=1-\\frac{1}{n+1} k=1∑n​k(k+1)1​=k=1∑n​k1​−k+11​=11​−21​+21​−31​+...−n+11​=1−n+11​ 有限微积分 离散数学中有一种与传统的无限微积分类似的有限微积分，能处理和式。 无限微积分有微分： Df(x)=lim⁡h→0f(x+h)−f(x)hDf(x)=\\lim_{h \\to 0} \\frac{f(x+h)-f(x)}{h} Df(x)=h→0lim​hf(x+h)−f(x)​ 而有限微积分则是差分： Δf(x)=f(x+1)−f(x)\\Delta f(x)=f(x+1)-f(x) Δf(x)=f(x+1)−f(x) Δ\\DeltaΔ 和 DDD 称为算子。 仿照 DDD，Δ\\DeltaΔ有以下运算法则。 Δ(f+g)=Δf+Δg\\Delta(f+g)=\\Delta f+\\Delta gΔ(f+g)=Δf+Δg Δ(fg)=gΔf+EfΔg\\Delta(fg)=g\\Delta f+Ef\\Delta gΔ(fg)=gΔf+EfΔg 其中 Ef(x)=f(x+1)Ef(x)=f(x+1)Ef(x)=f(x+1)。 证明： Δ(f(x)g(x))=f(x+1)g(x+1)−f(x)g(x)\\Delta(f(x)g(x))=f(x+1)g(x+1)-f(x)g(x) Δ(f(x)g(x))=f(x+1)g(x+1)−f(x)g(x) =f(x+1)g(x+1)−f(x+1)g(x)−f(x)g(x)+f(x+1)g(x)=f(x+1)g(x+1)-f(x+1)g(x)-f(x)g(x)+f(x+1)g(x) =f(x+1)g(x+1)−f(x+1)g(x)−f(x)g(x)+f(x+1)g(x) =f(x+1)[g(x+1)−g(x)]+g(x)[f(x+1)−f(x)]=f(x+1)[g(x+1)-g(x)]+g(x)[f(x+1)-f(x)] =f(x+1)[g(x+1)−g(x)]+g(x)[f(x+1)−f(x)] =Ef(x)Δg(x)+g(x)Δf(x)=Ef(x)\\Delta g(x)+g(x)\\Delta f(x) =Ef(x)Δg(x)+g(x)Δf(x) 无限微积分中有一个优美的结论： D(xn)=nxn−1D(x^n)=nx^{n-1} D(xn)=nxn−1 有限微积分也有一个类似的替代品，我们定义下降阶乘幂 xn‾x^{\\underline{n}}xn​： xn‾={x(x−1)(x−2)...(x−n+1)n&gt;01n=01(x+1)(x+2)...(x−n)n&lt;0 x^{\\underline{n}}= \\begin{cases} x(x-1)(x-2)...(x-n+1)&amp; n&gt;0 \\\\ 1 &amp; n=0 \\\\ \\frac{1}{(x+1)(x+2)...(x-n)} &amp; n&lt;0 \\end{cases} xn​=⎩⎪⎨⎪⎧​x(x−1)(x−2)...(x−n+1)1(x+1)(x+2)...(x−n)1​​n&gt;0n=0n&lt;0​ 正负下降幂的转换： x−k‾=1(x+k)k‾x^{\\underline {-k}}=\\frac{1}{(x+k)^{\\underline{k}}} x−k​=(x+k)k​1​ 下降幂对 Δ\\DeltaΔ 很合适。 Δ(xn‾)=(x+1)n‾−xn‾=[(x+1)−(x−n+1)]xn−1‾=nxn−1‾\\Delta (x^{\\underline n})=(x+1)^{\\underline n}-x^{\\underline n}=[(x+1)-(x-n+1)]x^{\\underline {n-1}}=nx^{\\underline{n-1}} Δ(xn​)=(x+1)n​−xn​=[(x+1)−(x−n+1)]xn−1​=nxn−1​ 于是我们有： Δ(xn‾)=nxn−1‾\\Delta (x^{\\underline n})=nx^{\\underline{n-1}} Δ(xn​)=nxn−1​ xn‾=Δ(xn+1‾n+1)x^{\\underline{n}}=\\Delta (\\frac{x^{\\underline {n+1}}}{n+1}) xn​=Δ(n+1xn+1​​) 无限微积分有牛顿-莱布尼茨公式： f(x)=DF(x)⟺∫abf(x)dx=F(x)∣ab=F(b)−F(a)f(x)=DF(x) \\Longleftrightarrow \\int^b_a f(x)dx=\\left. F(x)\\right\\vert_a^b=F(b)-F(a) f(x)=DF(x)⟺∫ab​f(x)dx=F(x)∣ab​=F(b)−F(a) 有限微积分一样有： f(x)=Δ(F(x))⟺∑abf(x)δx=F(x)∣ab=F(b)−F(a)f(x)=\\Delta(F(x)) \\Longleftrightarrow{\\textstyle\\sum^b_a}f(x)\\delta x=\\left.F(x)\\right\\vert_a^b=F(b)-F(a) f(x)=Δ(F(x))⟺∑ab​f(x)δx=F(x)∣ab​=F(b)−F(a) 其中 a,ba,ba,b 是左闭右开空间。 根据这个公式，我们现在可以很方便对某些和式求和，如下降幂和式求和，我们已经知道 xn‾=Δ(xn+1‾n+1)x^{\\underline{n}}=\\Delta (\\frac{x^{\\underline {n+1}}}{n+1})xn​=Δ(n+1xn+1​​)。 ∑0nxk‾δx=xk+1‾k+1∣0n=nk+1‾k+1{\\textstyle\\sum^n_0x}^{\\underline k}\\delta x=\\left.\\frac{x^{\\underline{k+1}}}{k+1}\\right \\vert_0^n=\\frac{n^{\\underline{k+1}}}{k+1} ∑0n​xk​δx=k+1xk+1​​∣∣∣∣​0n​=k+1nk+1​​ 根据定义可知有限微积分有以下性质 ∑abf(x)δx+∑bcf(x)δx=∑acf(x)δx\\sum^b_af(x)\\delta x+\\sum^c_bf(x)\\delta x=\\sum^c_af(x)\\delta x∑ab​f(x)δx+∑bc​f(x)δx=∑ac​f(x)δx ∑abf(x)δx±∑abg(x)δx=∑ab[f(x)±g(x)]δx\\sum^b_af(x)\\delta x\\pm\\sum^b_ag(x)\\delta x=\\sum^b_a[f(x)\\pm g(x)]\\delta x∑ab​f(x)δx±∑ab​g(x)δx=∑ab​[f(x)±g(x)]δx ∑abCf(x)δx=C∑abf(x)δx\\sum^b_aCf(x)\\delta x=C\\sum^b_af(x)\\delta x∑ab​Cf(x)δx=C∑ab​f(x)δx ∑f(x)Δ(g(x))δx+∑Eg(x)Δ(f(x))δx=f(x)g(x)\\sum f(x)\\Delta(g(x))\\delta x+\\sum Eg(x)\\Delta(f(x))\\delta x=f(x)g(x)∑f(x)Δ(g(x))δx+∑Eg(x)Δ(f(x))δx=f(x)g(x) 或写作 ∑f(x)Δ(g(x))δx=f(x)g(x)−∑Eg(x)Δ(f(x))δx\\sum f(x)\\Delta(g(x))\\delta x=f(x)g(x)-\\sum Eg(x)\\Delta(f(x))\\delta x∑f(x)Δ(g(x))δx=f(x)g(x)−∑Eg(x)Δ(f(x))δx 最后一个也叫做部分求和法则。 当和式是两个式子的乘积，且一部分是某一个简单式子的差分，另一部分有着一个简单的差分，我们可以通过这个法则将原问题化成更简单的形式。 下面是一些例题。 例一：∑x=0nax\\sum^n_{x=0}a^x∑x=0n​ax 先考虑等比数列的差分。 Δ(ax)=ax+1−ax=ax(x−1)\\Delta(a^x)=a^{x+1}-a^{x}=a^x(x-1) Δ(ax)=ax+1−ax=ax(x−1) 我们由此可以得到 axa^xax 的差分原函数来直接套公式。 ax=Δ(axa−1)a^x=\\Delta(\\frac{a^x}{a-1}) ax=Δ(a−1ax​) ∑x=0nax=∑0n+1Δ(axa−1)δx=axa−1∣0n+1=an+1−1a−1\\sum^n_{x=0}a^x={\\textstyle\\sum^{n+1}_0}\\Delta(\\frac{a^x}{a-1})\\delta x=\\left.\\frac{a^x}{a-1}\\right\\vert_0^{n+1}=\\frac{a^{n+1}-1}{a-1} x=0∑n​ax=∑0n+1​Δ(a−1ax​)δx=a−1ax​∣∣∣∣​0n+1​=a−1an+1−1​ 例二：∑i=0nxax\\sum^n_{i=0}xa^x∑i=0n​xax。 部分求和法则的应用。 ∑x=0nxax=∑0n+1xΔ(axa−1)δx\\sum^n_{x=0}xa^x={\\textstyle\\sum^{n+1}_0}x\\Delta(\\frac{a^x}{a-1})\\delta x x=0∑n​xax=∑0n+1​xΔ(a−1ax​)δx =(n+1)an+1a−1−(1a−1)∑0n+1ax+1δx=\\frac{(n+1)a^{n+1}}{a-1}-(\\frac{1}{a-1}){\\textstyle\\sum^{n+1}_0}a^{x+1}\\delta x =a−1(n+1)an+1​−(a−11​)∑0n+1​ax+1δx =(n+1)an+1a−1−an+2−1(a−1)2+1a−1=\\frac{(n+1)a^{n+1}}{a-1}-\\frac{a^{n+2}-1}{(a-1)^2}+\\frac{1}{a-1} =a−1(n+1)an+1​−(a−1)2an+2−1​+a−11​ =nan+2−(n+1)an+1+a(a−1)2=\\frac{na^{n+2}-(n+1)a^{n+1}+a}{(a-1)^2} =(a−1)2nan+2−(n+1)an+1+a​ 例三：Sk=∑x=0naxxk‾S_k=\\sum^n_{x=0}a^xx^{\\underline k}Sk​=∑x=0n​axxk​ Sk=∑0n+1Δ(axa−1)xk‾δxS_k={\\textstyle\\sum^{n+1}_0}\\Delta(\\frac{a^x}{a-1})x^{\\underline k}\\delta x Sk​=∑0n+1​Δ(a−1ax​)xk​δx =an+1(n+1)k‾a−1−∑0n+1ax+1Δ(xk‾)δxa−1=\\frac{a^{n+1}(n+1)^{\\underline k}}{a-1}-\\frac{\\sum^{n+1}_0a^{x+1}\\Delta(x^{\\underline k})\\delta x}{a-1} =a−1an+1(n+1)k​​−a−1∑0n+1​ax+1Δ(xk​)δx​ =an+1(n+1)k‾a−1−ak∑0n+1axxk−1‾δxa−1=\\frac{a^{n+1}(n+1)^{\\underline k}}{a-1}-\\frac{ak\\sum^{n+1}_0a^xx^{\\underline {k-1}}\\delta x}{a-1} =a−1an+1(n+1)k​​−a−1ak∑0n+1​axxk−1​δx​ =an+1(n+1)k‾−akSk−1a−1=\\frac{a^{n+1}(n+1)^{\\underline k}-akS_{k-1}}{a-1} =a−1an+1(n+1)k​−akSk−1​​ 可以 O(k)O(k)O(k) 递推。 例四：∑i=1n1∏j=ii+m−1j\\sum^n_{i=1}\\frac{1}{\\prod^{i+m-1}_{j=i}j}∑i=1n​∏j=ii+m−1​j1​ (P1625) ∑i=1n1∏j=ii+m−1j=∑i=1n1(i+m−1)m‾\\sum^n_{i=1}\\frac{1}{\\prod^{i+m-1}_{j=i}j}=\\sum^n_{i=1}\\frac{1}{(i+m-1)^{\\underline m}} i=1∑n​∏j=ii+m−1​j1​=i=1∑n​(i+m−1)m​1​ =∑i=0n−11(i+m)m‾=∑i=0n−1i−m‾=∑0nx−m‾δx=\\sum^{n-1}_{i=0}\\frac{1}{(i+m)^{\\underline m}}=\\sum^{n-1}_{i=0}i^{\\underline{-m}}={\\textstyle\\sum^{n}_0}x^{\\underline{-m}}\\delta x =i=0∑n−1​(i+m)m​1​=i=0∑n−1​i−m​=∑0n​x−m​δx =x−m+1‾−m+1∣0n=n−m+1‾−0−m+1‾−m+1,m≠1=\\left.\\frac{x^{\\underline{-m+1}}}{-m+1}\\right \\vert_0^{n}=\\frac{n^{\\underline{-m+1}}-0^{\\underline{-m+1}}}{-m+1},m\\ne1 =−m+1x−m+1​​∣∣∣∣​0n​=−m+1n−m+1​−0−m+1​​,m​=1 当 m=1m=1m=1 时，∑i=1n1∏j=ii+m−1j=Hn\\sum^n_{i=1}\\frac{1}{\\prod^{i+m-1}_{j=i}j}=H_n∑i=1n​∏j=ii+m−1​j1​=Hn​。 例五：∑x=0nx2\\sum^n_{x=0} x^2∑x=0n​x2。 x2=x2‾+x1‾x^2=x^{\\underline{2}}+x^{\\underline{1}} x2=x2​+x1​ ∑x=0nx2=∑0n+1(x2‾+x1‾)δx=x3‾3+x2‾2∣0n+1=(n+1)3‾3+(n+1)2‾2=n(n+1)(2n+1)6\\sum^n_{x=0} x^2={\\textstyle\\sum^{n+1}_0}(x^{\\underline 2}+x^{\\underline 1})\\delta x=\\left.\\frac{x^{\\underline{3}}}{3}+\\frac{x^{\\underline{2}}}{2}\\right \\vert_0^{n+1}=\\frac{(n+1)^{\\underline{3}}}{3}+\\frac{(n+1)^{\\underline{2}}}{2}=\\frac{n(n+1)(2n+1)}{6} x=0∑n​x2=∑0n+1​(x2​+x1​)δx=3x3​​+2x2​​∣∣∣∣​0n+1​=3(n+1)3​​+2(n+1)2​​=6n(n+1)(2n+1)​ 例五启示我们可以将正常幂转化成下降幂来计算，事实上两类斯特林数给出了互相转换的公式。 xn=∑k=0n\\{nk\\}xk‾x^n=\\sum_{k=0}^n{n\\brace k}x^{\\underline{k}} xn=k=0∑n​{kn​}xk​ xn‾=∑k=0n[nk](−1)n−kxkx^{\\underline{n}}=\\sum_{k=0}^n{n\\brack k}(-1)^{n-k}x^k xn​=k=0∑n​[kn​](−1)n−kxk 所以我们有： ∑x=0nxk=∑i=0k\\{ki\\}∑x=0nxi‾=∑i=0k\\{ki\\}(n+1)i+1‾i+1\\sum^n_{x=0} x^k=\\sum_{i=0}^k{k\\brace i}\\sum^n_{x=0}x^{\\underline i}=\\sum_{i=0}^k{k\\brace i}\\frac{(n+1)^{\\underline{i+1}}}{i+1} x=0∑n​xk=i=0∑k​{ik​}x=0∑n​xi​=i=0∑k​{ik​}i+1(n+1)i+1​​ P4948 P5364 数论 剩余系 模运算的一些运算法则。 a mod b=a−b⌊ab⌋a\\bmod b=a-b\\left \\lfloor \\frac{a}{b}\\right \\rflooramodb=a−b⌊ba​⌋ a≡ba\\equiv ba≡b 且 c≡d⟺a±c≡b±d(modm)c\\equiv d \\Longleftrightarrow a\\pm c \\equiv b\\pm d \\pmod mc≡d⟺a±c≡b±d(modm) ad≡bd(modm)⟺a≡b(modmgcd(m,d))ad\\equiv bd\\pmod m\\Longleftrightarrow a\\equiv b \\pmod {\\frac{m}{gcd(m,d)}}ad≡bd(modm)⟺a≡b(modgcd(m,d)m​) a≡b(modmd)⟹a≡b(modm)a\\equiv b\\pmod {md}\\Longrightarrow a\\equiv b\\pmod {m}a≡b(modmd)⟹a≡b(modm) a≡b(modmn)⟺a≡b(modm),a≡b(modn)(n⊥m)a\\equiv b \\pmod {mn}\\Longleftrightarrow a\\equiv b\\pmod m,a\\equiv b\\pmod n (n\\perp m)a≡b(modmn)⟺a≡b(modm),a≡b(modn)(n⊥m) 下面是某些经典定理及其证明。 gcd⁡(a,b)=gcd⁡(b mod a,a)\\gcd(a,b)=\\gcd(b\\bmod a,a)gcd(a,b)=gcd(bmoda,a) 证明：由于 gcd⁡(a,b)=d⟺gcd⁡(ad,bd)=1\\gcd(a,b)=d\\Longleftrightarrow \\gcd(\\frac{a}{d},\\frac{b}{d})=1gcd(a,b)=d⟺gcd(da​,db​)=1，所以我们只需要证明当 a⊥ba\\perp ba⊥b 时，a mod b⊥ba\\bmod b\\perp bamodb⊥b。a mod b=a−b×ka\\bmod b=a-b\\times kamodb=a−b×k，对于每一个 bbb 的因子，都是 b×kb\\times kb×k 的因子且不是 aaa 的因子，一定无法整除 a−b×ka-b\\times ka−b×k，所以 a mod b⊥ba\\bmod b\\perp bamodb⊥b。 exgcd：给定 a,ba,ba,b，求 ax+by=gcd⁡(a,b)ax+by=\\gcd(a,b)ax+by=gcd(a,b)。 根据 gcd⁡(a,b)=gcd⁡(b mod a,a)\\gcd(a,b)=\\gcd(b\\bmod a,a)gcd(a,b)=gcd(bmoda,a)，考虑我们已经求出 (b mod a)x′+ay′=gcd⁡(b mod a,a)(b\\bmod a)x&#x27;+ay&#x27;=\\gcd(b\\bmod a,a)(bmoda)x′+ay′=gcd(bmoda,a)，如何求 x,yx,yx,y。 令 d=gcd(a,b)d=gcd(a,b)d=gcd(a,b)。 (b mod a)x′+ay′=d(b\\bmod a)x&#x27;+ay&#x27;=d (bmoda)x′+ay′=d (b−a⌊ba⌋)x′+ay′=d(b-a\\left \\lfloor \\frac{b}{a}\\right \\rfloor )x&#x27;+ay&#x27;=d (b−a⌊ab​⌋)x′+ay′=d a(y′−x′⌊ba⌋)+bx′=da(y&#x27;-x&#x27;\\left \\lfloor \\frac{b}{a}\\right \\rfloor )+bx&#x27;=d a(y′−x′⌊ab​⌋)+bx′=d x=y′−x′⌊ba⌋,y=x′x=y&#x27;-x&#x27;\\left \\lfloor \\frac{b}{a}\\right \\rfloor,y=x&#x27; x=y′−x′⌊ab​⌋,y=x′ 递归求解即可，边界为 aaa 或 bbb 为 000。 定理：mmm 个数 0 mod m,n mod m,2n mod m,...,(m−1) mod m0\\bmod m,n\\bmod m,2n\\bmod m,...,(m-1)\\bmod m 0modm,nmodm,2nmodm,...,(m−1)modm 按某种次序恰好组成 md\\frac{m}{d}dm​ 个值 0,d,2d,...,m−d0,d,2d,...,m-d 0,d,2d,...,m−d 每个值都出现 ddd 次，其中 d=gcd(n,m)d=gcd(n,m)d=gcd(n,m) 证明：首先证每个值都出现 ddd 次。 k1n≡k2n(modm)⟺k1≡k2(modmd)k_1n\\equiv k_2n\\pmod m\\Longleftrightarrow k_1\\equiv k_2 \\pmod {\\frac{m}{d}} k1​n≡k2​n(modm)⟺k1​≡k2​(moddm​) 所以每隔 md\\frac{m}{d}dm​ 个数就有与其相等的值，每个值恰好有 ddd 个。 由于每个数模 mmm 必定等于 ddd 的小于 mmm 的倍数，而且每个值恰好有 ddd 个，所以 nnn 个数一定恰好组成 0,d,2d,...,m−d0,d,2d,...,m-d0,d,2d,...,m−d 这 md\\frac{m}{d}dm​ 个值。 费马小定理：ap−1≡1(modp)a^{p-1}\\equiv1\\pmod pap−1≡1(modp) 其中，ppp 是素数。 证明：考虑 a×2a×3a×...×(p−1)a=(p−1)!ap−1a\\times 2a\\times 3a\\times ... \\times (p-1)a = (p-1)!a^{p-1}a×2a×3a×...×(p−1)a=(p−1)!ap−1,对这个式子取模，得到 a mod p×2a mod p×3n mod p×...×(p−1)a mod pa\\bmod p\\times 2a\\bmod p\\times 3n\\bmod p\\times ... \\times (p-1)a\\bmod pamodp×2amodp×3nmodp×...×(p−1)amodp。 刚才已经证明过，a mod p,2a mod p,3a mod p...(p−1)a mod pa\\bmod p,2a\\bmod p,3a\\bmod p...(p-1)a\\bmod pamodp,2amodp,3amodp...(p−1)amodp 是 1,2,...p−11,2,...p-11,2,...p−1 的某种排列，因此a mod p×2a mod p×3a mod p×...×(p−1)a mod p=(p−1)!a\\bmod p\\times 2a\\bmod p\\times 3a\\bmod p\\times ... \\times (p-1)a\\bmod p=(p-1)!amodp×2amodp×3amodp×...×(p−1)amodp=(p−1)! (p−1)!ap−1≡(p−1)!(modp)(p-1)!a^{p-1}\\equiv (p-1)!\\pmod p (p−1)!ap−1≡(p−1)!(modp) ap−1≡1(modp)a^{p-1}\\equiv 1\\pmod p ap−1≡1(modp) 除此之外，用多项式定理也可以证明费马小定理。 欧拉定理：aφ(p)≡1(modp),p⊥aa^{\\varphi (p)}\\equiv1\\pmod p,p\\perp aaφ(p)≡1(modp),p⊥a 证明：由于 ppp 不再是质数，因此 (p−1)!(p-1)!(p−1)! 不一定与 ppp 互质，从 (p−1)!ap−1≡(p−1)!(modp)(p-1)!a^{p-1}\\equiv (p-1)!\\pmod p(p−1)!ap−1≡(p−1)!(modp) 无法再得到 ap−1≡1(modp)a^{p-1}\\equiv 1\\pmod pap−1≡1(modp)。 所以我们只选取 kakaka 与 ppp 互质的乘起来，一共有 φ(p)\\varphi (p)φ(p) 个数，其余部分证明与费马小定理相同。 扩展欧拉定理： ab≡{ab mod φ(m)gcd(a,m)=1abgcd(a,m)≠1,b&lt;φ(m)ab mod φ(m)+φ(m)gcd(a,m)≠1,b≥φ(m)(modm) a^b\\equiv \\begin{cases} a^{b\\bmod \\varphi(m)}&amp; gcd(a,m)=1 \\\\ a^b &amp; gcd(a,m)\\ne 1,b&lt;\\varphi(m) \\\\ a^{b\\bmod\\varphi(m)+\\varphi(m)} &amp; gcd(a,m)\\ne 1,b\\ge\\varphi(m) \\end{cases}\\pmod m ab≡⎩⎪⎨⎪⎧​abmodφ(m)ababmodφ(m)+φ(m)​gcd(a,m)=1gcd(a,m)​=1,b&lt;φ(m)gcd(a,m)​=1,b≥φ(m)​(modm) 证明：式子中前两个结论显然，只证明 ab≡ab mod φ(m)+φ(m)(modm)a^b\\equiv a^{b\\bmod\\varphi(m)+\\varphi(m)} \\pmod mab≡abmodφ(m)+φ(m)(modm)。 令 m=∏picim=\\prod p_i^{c_i}m=∏pici​​，只要 ab≡ab mod φ(m)+φ(m)(modpici)a^b\\equiv a^{b\\bmod\\varphi(m)+\\varphi(m)} \\pmod {p_i^{c_i}}ab≡abmodφ(m)+φ(m)(modpici​​)，原式就成立。因为 gcd(a,m)≠1gcd(a,m)\\ne 1gcd(a,m)​=1，所以存在 pip_ipi​ 满足 a=kpia=kp_ia=kpi​。 根据最初条件和 φ\\varphiφ 函数的性质，有以下不等式。 b≥φ(m)≥φ(pici)≥cib\\ge\\varphi(m)\\ge\\varphi(p_i^{c_i})\\ge c_i b≥φ(m)≥φ(pici​​)≥ci​ 将 aaa 转化成 ppp 的倍数的形式 ab=kbpib=kbpib−cipicia^b=k^bp^b_i=k^bp^{b-c_i}_ip^{c_i}_i ab=kbpib​=kbpib−ci​​pici​​ 也就是说，aba^bab 是 pcip^{c_i}pci​ 的倍数，所以 ab≡0(modpci)a^b\\equiv 0 \\pmod{p^{c_i}}ab≡0(modpci​)。 恒等式一边我们得到了 000，我们只需证另一边 ab mod φ(m)+φ(m)a^{b\\bmod\\varphi(m)+\\varphi(m)}abmodφ(m)+φ(m) 也等于 000 就行了。同样的操作。 ab mod φ(m)+φ(m)=kb mod φ(m)+φ(m)pib mod φ(m)+φ(m)=kb mod φ(m)+φ(m)pib mod φ(m)+φ(m)−cipicia^{b\\bmod\\varphi(m)+\\varphi(m)}=k^{b\\bmod\\varphi(m)+\\varphi(m)}p_i^{b\\bmod\\varphi(m)+\\varphi(m)}=k^{b\\bmod\\varphi(m)+\\varphi(m)}p_i^{b\\bmod\\varphi(m)+\\varphi(m)-c_i}p_i^{c_i} abmodφ(m)+φ(m)=kbmodφ(m)+φ(m)pibmodφ(m)+φ(m)​=kbmodφ(m)+φ(m)pibmodφ(m)+φ(m)−ci​​pici​​ 同样整除 picip_i^{c_i}pici​​。证毕。 威尔逊定理：(p−1)!≡p−1(modp)(p-1)!\\equiv p-1 \\pmod p(p−1)!≡p−1(modp)。 证明：首先每个非零数在模质数意义下都有逆元。根据 x2≡1x^2\\equiv 1x2≡1 的解为 ±1\\pm 1±1 可知，除了 ±1\\pm 1±1 每个数的逆元不是自身。 (p−1)!(p-1)!(p−1)! 从 111 乘到 p−1p-1p−1 ，其中不考虑 111 和 p−1p-1p−1 每个数都一定能与自己的逆元两两相乘，最后就剩下 p−1p-1p−1。因此 (p−1)!≡p−1(modp)(p-1)!\\equiv p-1 \\pmod p(p−1)!≡p−1(modp)。 φ\\varphiφ 函数和 μ\\muμ 函数 积性函数：若算术函数 fff 满足 f(1)=1f(1)=1f(1)=1 且 f(ab)=f(a)f(b),a⊥bf(ab)=f(a)f(b),a\\perp bf(ab)=f(a)f(b),a⊥b，那么 fff 被称为积性函数。 狄利克雷卷积：(f∗g)(n)=∑d∣nf(d)g(nd)(f*g)(n)=\\sum_{d\\mid n}f(d)g(\\frac{n}{d})(f∗g)(n)=∑d∣n​f(d)g(dn​) 如果 f,gf,gf,g 是积性函数，f∗gf*gf∗g 也是积性函数。 若 f∗g=εf*g=\\varepsilonf∗g=ε，那么 fff 和 ggg 互逆。 积性函数的逆也是积性函数。 常用积性函数： 名称 符号 定义 卷积 恒等函数 1(n)1(n)1(n) 恒为 111 元函数 ε(n)\\varepsilon(n)ε(n) [n=1][n=1][n=1] 单位函数 id(n)id(n)id(n) nnn 幂函数 idk(n)id^k(n)idk(n) nkn^knk 莫比乌斯函数 μ(n)\\mu(n)μ(n) 1−11^{-1}1−1 μ∗1=ε\\mu*1=\\varepsilonμ∗1=ε 欧拉函数 φ(n)\\varphi(n)φ(n) 小于等于 nnn 中与 nnn 互质的数的个数 φ∗1=id\\varphi*1=idφ∗1=id 约数个数函数 d(n)d(n)d(n) 约数个数 d=1∗1d=1*1d=1∗1 约数和函数 σ(n)\\sigma (n)σ(n) 约数和 σ=id∗1\\sigma=id*1σ=id∗1 除数函数 σk(n)\\sigma^k (n)σk(n) 约数的 kkk 次方和 σk=idk∗1\\sigma^k=id^k*1σk=idk∗1 一个积性函数完全由它在质数幂的值所定义，因为任何正整数都能拆成若干个指数幂相乘。 f(n)=∏pf(pnp),n=∏ppnpf(n)=\\prod _pf(p^{n_p}),n=\\prod_pp^{n_p} f(n)=p∏​f(pnp​),n=p∏​pnp​ 欧拉函数 φ(n)\\varphi(n)φ(n) 表示小于 nnn 与 nnn 互质的数的数量。显然是积性函数。 φ(pk)=pk−pk−1\\varphi(p^k)=p^k-p^{k-1} φ(pk)=pk−pk−1 其中 ppp 是质数。由于只有含有因子 ppp 才不与 pkp^kpk 次方互质，而 pkp^kpk 中含因子 ppp 的有 pkp=pk−1\\frac{p^k}{p}=p^{k-1}ppk​=pk−1 个，所以 φ(pk)=pk−pk−1\\varphi(p^k)=p^k-p^{k-1}φ(pk)=pk−pk−1。 根据 f(n)=∏pf(pnp)f(n)=\\prod _pf(p^{n_p})f(n)=∏p​f(pnp​)，我们可以得到 φ\\varphiφ 的公式。 φ(n)=∏p∣n(pnp−pnp−1)=n∏p∣n(1−1p)\\varphi(n)=\\prod_{p\\mid n}(p^{n_p}-p^{n_p-1})=n\\prod_{p\\mid n}(1-\\frac{1}{p}) φ(n)=p∣n∏​(pnp​−pnp​−1)=np∣n∏​(1−p1​) 关于 φ\\varphiφ 还有一个公式： ∑d∣nφ(d)=n\\sum_{d\\mid n}\\varphi(d)=n d∣n∑​φ(d)=n 证明： 根据定义有： φ(n)=∑i=1n[gcd(n,i)=1]\\varphi(n)=\\sum^n_{i=1}[gcd(n,i)=1] φ(n)=i=1∑n​[gcd(n,i)=1] 将 nnn 用类似方式表示。 n=∑i=1n∑j=1n[gcd(n,j)=i]n=\\sum^n_{i=1}\\sum^n_{j=1}[gcd(n,j)=i] n=i=1∑n​j=1∑n​[gcd(n,j)=i] 显然，如果 gcd(n,j)=igcd(n,j)=igcd(n,j)=i，那么 iii 是 nnn 的因子，所以用 nnn 的因子替换 iii。 n=∑d∣n∑j=1n[gcd(nd,j)=1]n=\\sum_{d\\mid n}\\sum^n_{j=1}[gcd(\\frac{n}{d},j)=1] n=d∣n∑​j=1∑n​[gcd(dn​,j)=1] n=∑d∣nφ(nd)=∑d∣nφ(d)n=\\sum_{d\\mid n}\\varphi(\\frac{n}{d})=\\sum_{d\\mid n}\\varphi(d) n=d∣n∑​φ(dn​)=d∣n∑​φ(d) 现在有两个函数 fff 和 FFF 满足 F(n)=∑d∣nf(d)F(n)=\\sum_{d\\mid n}f(d)F(n)=∑d∣n​f(d)。 也就是 F=1∗fF=1*fF=1∗f。 如果我们已经知道了 FFF，如何求 fff？ 很简单，两边同时乘上 111 函数的逆，得到 F∗1−1=fF*1^{-1}=fF∗1−1=f。 1−11^{-1}1−1 被命名为莫比乌斯函数 μ\\muμ。 莫比乌斯函数的定义：μ∗1=ε\\mu*1=\\varepsilonμ∗1=ε，或写作 ∑d∣nμ(d)=[n=1]\\sum_{d|n}\\mu(d)=[n=1]∑d∣n​μ(d)=[n=1]。 通过 FFF 求 fff 的操作叫莫比乌斯反演，一般写作： F(n)=∑d∣nf(d)⟺f(n)=∑d∣nμ(d)F(nd)F(n)=\\sum_{d\\mid n}f(d) \\Longleftrightarrow f(n)=\\sum_{d\\mid n}\\mu(d)F(\\frac{n}{d}) F(n)=d∣n∑​f(d)⟺f(n)=d∣n∑​μ(d)F(dn​) 我们现在想要求出 μ\\muμ，我们已知 μ\\muμ 是积性函数，所以 μ(1)=1\\mu(1)=1μ(1)=1。 根据 ∑d∣nμ(d)=[n=1]\\sum_{d|n}\\mu(d)=[n=1]∑d∣n​μ(d)=[n=1]，我们可以用类似递归的方式求出所有 μ\\muμ 的值。 先尝试代入质数 ppp，因为 μ(1)+μ(p)=0\\mu(1)+\\mu(p)=0μ(1)+μ(p)=0，显然 μ(p)\\mu(p)μ(p) 必须是 −1-1−1。 然后试试 pkp^kpk，因为μ(pk)+μ(pk−1)+...+μ(p)+μ(1)=0\\mu(p^k)+\\mu(p^{k-1})+...+\\mu(p)+\\mu(1)=0μ(pk)+μ(pk−1)+...+μ(p)+μ(1)=0，显然 μ(pk)=0\\mu(p^k)=0μ(pk)=0。 然后我们得到了 μ\\muμ 的定义： μ(n)={1n=1(−1)kn=∏pp0other \\mu(n)= \\begin{cases} 1&amp; n=1 \\\\ (-1)^k &amp; n = \\prod_pp \\\\ 0 &amp;other \\end{cases} μ(n)=⎩⎪⎨⎪⎧​1(−1)k0​n=1n=∏p​pother​ 也就是当 nnn 含有平方因子时为零，否则为 −1-1−1 的质因子数次方。 一般来说，莫比乌斯反演来求某些和式都必须交换求和顺序与整除分块。 一些结论 id=1∗φid=1*\\varphiid=1∗φ，id∗μ=φid*\\mu=\\varphiid∗μ=φ σk=1∗idk\\sigma^k=1*id^kσk=1∗idk ∑i=1nd(i)=∑i=1n⌊ni⌋\\sum^n_{i=1}d(i)=\\sum^n_{i=1}\\left \\lfloor \\frac{n}{i}\\right \\rfloor∑i=1n​d(i)=∑i=1n​⌊in​⌋ μ(ij)=[gcd(i,j)=1]μ(i)μ(j)\\mu(ij)=[gcd(i,j)=1]\\mu(i)\\mu(j)μ(ij)=[gcd(i,j)=1]μ(i)μ(j) d(ij)=∑x∣i∑y∣j[x⊥y]d(ij)=\\sum_{x\\mid i}\\sum_{y\\mid j}[x\\perp y]d(ij)=∑x∣i​∑y∣j​[x⊥y] φ(ij)=φ(i)φ(j)gcd⁡(i,j)φ(gcd⁡(i,j))\\varphi(ij)=\\frac{\\varphi(i)\\varphi(j)\\gcd(i,j)}{\\varphi(\\gcd(i,j))}φ(ij)=φ(gcd(i,j))φ(i)φ(j)gcd(i,j)​ 莫反的例题： 例一：YY的GCD 求 1≤i≤n,1≤j≤m1\\le i \\le n,1\\le j\\le m1≤i≤n,1≤j≤m 中 gcd(i,j)gcd(i,j)gcd(i,j) 为质数的数量。TTT 组询问，n,m≤107,T≤104n,m\\le 10^7,T\\le 10^4n,m≤107,T≤104。 ∑i=1n∑j=1m[gcd⁡(i,j)∈prime]\\sum^n_{i=1}\\sum^m_{j=1}[\\gcd(i,j)\\in prime] i=1∑n​j=1∑m​[gcd(i,j)∈prime] 经典套路，枚举 gcd⁡\\gcdgcd的值，改变枚举变量。 =∑p∈prime∑i=1⌊np⌋∑j=1⌊mp⌋[gcd⁡(i,j)=1]=\\sum_{p\\in prime}\\sum^{\\left \\lfloor \\frac{n}{p}\\right \\rfloor}_{i=1}\\sum^{\\left \\lfloor \\frac{m}{p}\\right \\rfloor}_{j=1}[\\gcd(i,j)=1] =p∈prime∑​i=1∑⌊pn​⌋​j=1∑⌊pm​⌋​[gcd(i,j)=1] 套公式 =∑p∈prime∑i=1⌊np⌋∑j=1⌊mp⌋∑d∣gcd⁡(i,j)μ(d)=\\sum_{p\\in prime}\\sum^{\\left \\lfloor \\frac{n}{p}\\right \\rfloor}_{i=1}\\sum^{\\left \\lfloor \\frac{m}{p}\\right \\rfloor}_{j=1}\\sum_{d\\mid \\gcd(i,j)}\\mu(d) =p∈prime∑​i=1∑⌊pn​⌋​j=1∑⌊pm​⌋​d∣gcd(i,j)∑​μ(d) 显然，d∣gcd⁡(i,j)d\\mid \\gcd(i,j)d∣gcd(i,j) 意味着 d∣i,d∣jd\\mid i,d\\mid jd∣i,d∣j，再次改变枚举变量。 =∑p∈prime∑d=1μ(d)∑i=1⌊npd⌋∑j=1⌊mpd⌋1=\\sum_{p\\in prime}\\sum_{d=1}\\mu(d)\\sum^{\\left \\lfloor \\frac{n}{pd}\\right \\rfloor}_{i=1}\\sum^{\\left \\lfloor \\frac{m}{pd}\\right \\rfloor}_{j=1}1 =p∈prime∑​d=1∑​μ(d)i=1∑⌊pdn​⌋​j=1∑⌊pdm​⌋​1 =∑p∈prime∑d=1μ(d)⌊npd⌋⌊mpd⌋=\\sum_{p\\in prime}\\sum_{d=1}\\mu(d)\\left \\lfloor \\frac{n}{pd}\\right \\rfloor\\left \\lfloor \\frac{m}{pd}\\right \\rfloor =p∈prime∑​d=1∑​μ(d)⌊pdn​⌋⌊pdm​⌋ 想办法消掉一个循环，考虑把 μ\\muμ 提出来，我们可以枚举 pdpdpd。 =∑i=1n∑d∣i,id∈primeμ(d)⌊ni⌋⌊mi⌋=\\sum^n_{i=1}\\sum_{d\\mid i,\\frac{i}{d}\\in prime}\\mu(d)\\left \\lfloor \\frac{n}{i}\\right \\rfloor\\left \\lfloor \\frac{m}{i}\\right \\rfloor =i=1∑n​d∣i,di​∈prime∑​μ(d)⌊in​⌋⌊im​⌋ 令 g(n)=∑d∣n,d∈primeμ(nd)g(n)=\\sum_{d\\mid n,d\\in prime}\\mu(\\frac{n}{d})g(n)=∑d∣n,d∈prime​μ(dn​)，g(n)g(n)g(n) 可以用埃筛计算出来。 =∑i=1n⌊ni⌋⌊mi⌋g(i)=\\sum^n_{i=1}\\left \\lfloor \\frac{n}{i}\\right \\rfloor\\left \\lfloor \\frac{m}{i}\\right \\rfloor g(i) =i=1∑n​⌊in​⌋⌊im​⌋g(i) 复杂度 O(Tn+nlog⁡log⁡n)O(T\\sqrt n+n\\log\\log n)O(Tn​+nloglogn)。 例二：LCMs 给定 nnn 和正整数数列 a1,a2,...,ana_1,a_2,...,a_na1​,a2​,...,an​，求 ∑i=1n∑j=i+1nlcm(ai,aj)\\sum^n_{i=1}\\sum^n_{j=i+1}lcm(a_i,a_j)∑i=1n​∑j=i+1n​lcm(ai​,aj​)，n≤2×105,ai≤106n\\le 2\\times 10^5,a_i\\le10^6n≤2×105,ai​≤106。 首先有 ∑i=1n∑j=i+1nai,j=12(∑i=1n∑j=1nai,j−∑i=1nai,i)\\sum^n_{i=1}\\sum^n_{j=i+1}a_{i,j}=\\frac{1}{2}(\\sum^n_{i=1}\\sum^n_{j=1}a_{i,j}-\\sum^n_{i=1}a_{i,i})∑i=1n​∑j=i+1n​ai,j​=21​(∑i=1n​∑j=1n​ai,j​−∑i=1n​ai,i​)。 因此原问题变为: 12(∑i=1n∑j=1nlcm(ai,aj)−∑i=1nai)\\frac{1}{2}(\\sum^n_{i=1}\\sum^n_{j=1}lcm(a_i,a_j)-\\sum^n_{i=1}a_i) 21​(i=1∑n​j=1∑n​lcm(ai​,aj​)−i=1∑n​ai​) 我们只用考虑前半部分，根据 lcm(a,b)=abgcd⁡(a,b)lcm(a,b)=\\frac{ab}{\\gcd(a,b)}lcm(a,b)=gcd(a,b)ab​ 得： ∑i=1n∑j=1naiajgcd⁡(a,b)\\sum^n_{i=1}\\sum^n_{j=1}\\frac{a_ia_j}{\\gcd(a,b)} i=1∑n​j=1∑n​gcd(a,b)ai​aj​​ 经典套路枚举 gcd⁡\\gcdgcd 的值。 =∑dN1d∑i=1n∑j=1naiaj[gcd⁡(ai,bi)=d]=\\sum^N_d\\frac{1}{d}\\sum^n_{i=1}\\sum^n_{j=1}a_ia_j[\\gcd(a_i,b_i)=d] =d∑N​d1​i=1∑n​j=1∑n​ai​aj​[gcd(ai​,bi​)=d] =∑dN1d∑i=1n∑j=1naiaj[d∣ai][d∣aj]∑t∣gcd⁡(aid,bid)μ(t)=\\sum^N_d\\frac{1}{d}\\sum^n_{i=1}\\sum^n_{j=1}a_ia_j[d\\mid a_i][d\\mid a_j]\\sum_{t\\mid\\gcd(\\frac{a_i}d,\\frac{b_i}d)}\\mu(t) =d∑N​d1​i=1∑n​j=1∑n​ai​aj​[d∣ai​][d∣aj​]t∣gcd(dai​​,dbi​​)∑​μ(t) =∑dN∑t⌊Nd⌋μ(t)d∑i=1n∑j=1naiaj[td∣ai][td∣aj]=\\sum^N_d\\sum^{\\left\\lfloor\\frac N d\\right\\rfloor}_{t}\\frac{\\mu(t)}{d}\\sum^n_{i=1}\\sum^n_{j=1}a_ia_j[td\\mid a_i][td\\mid a_j] =d∑N​t∑⌊dN​⌋​dμ(t)​i=1∑n​j=1∑n​ai​aj​[td∣ai​][td∣aj​] =∑dN∑t⌊Nd⌋μ(t)d(∑i=1nai[td∣ai])2=\\sum^N_d\\sum^{\\left\\lfloor\\frac N d\\right\\rfloor}_{t}\\frac{\\mu(t)}{d}(\\sum^n_{i=1}a_i[td\\mid a_i])^2 =d∑N​t∑⌊dN​⌋​dμ(t)​(i=1∑n​ai​[td∣ai​])2 令 g(d)=∑i=1nai[d∣ai]g(d)=\\sum^n_{i=1}a_i[d\\mid a_i]g(d)=∑i=1n​ai​[d∣ai​]，考虑如何求 g(d)g(d)g(d)，我们可以用一个桶来存储 aia_iai​，这样就只用枚举 ddd 的倍数求和就可以预处理g(d)g(d)g(d)了。 二项式系数 最重要的十个二项式系数恒等式。 (nk)=n!k!(n−k)!,整数0≤k≤n 阶乘展开式(1)(nk)=(nn−k),整数n≥0,k是整数对称恒等式(2)(nk)=nk(n−1k−1),整数k≠0 吸收恒等式(3)(nm)=(n−1m)+(n−1m−1),k是整数 加法恒等式(4)(nm)=(−1)m(m−n−1m),k是整数上指标反转(5)(nm)(mk)=(nk)(n−km−k),n,m是整数 三项式版恒等式(6)∑k(nk)xkyn−k=(x+y)n,整数n≥0或∣xy∣≤1 二项式定理(7)∑k&lt;=m(n+kk)=(n+m+1m),n是整数 平行求和(8)∑k=0n(km)=(n+1m+1),整数n,m≥0 上指标求和(9)∑k(nk)(ms−k)=(n+ms),n是整数范德蒙德卷积(10)\\boxed{\\begin{aligned} \\binom{n}{k}=\\frac{n!}{k!(n-k)!},整数 0\\le k\\le n \\qquad\\qquad\\qquad\\qquad\\quad \\ \\ 阶乘展开式 &amp;&amp;(1)\\\\ \\binom{n}{k}=\\binom{n}{n-k},整数 n\\ge0,k是整数 \\qquad\\qquad\\qquad\\qquad 对称恒等式 &amp;&amp;(2)\\\\ \\binom{n}{k}=\\frac n k\\binom{n-1}{k-1},整数 k\\ne0\\qquad\\qquad\\qquad\\qquad\\qquad\\quad \\ 吸收恒等式&amp;&amp;(3)\\\\ \\binom{n}{m}=\\binom{n-1}{m}+\\binom{n-1}{m-1},k 是整数\\qquad\\qquad\\qquad\\quad \\ \\ 加法恒等式&amp;&amp;(4)\\\\ \\binom{n}{m}=(-1)^m\\binom{m-n-1}{m},k 是整数\\qquad \\qquad \\qquad\\qquad 上指标反转&amp;&amp;(5)\\\\ \\binom{n}{m}\\binom{m}{k}=\\binom{n}{k}\\binom{n-k}{m-k},n,m 是整数\\qquad\\qquad \\ \\ \\ 三项式版恒等式&amp;&amp;(6)\\\\ \\sum_k\\binom{n}{k}x^ky^{n-k}=(x+y)^n,整数 n\\ge0或 \\left | \\frac{x}{y} \\right |\\le1\\ \\qquad\\ \\ \\ \\ 二项式定 理&amp;&amp;(7)\\\\ \\sum_{k&lt;=m}\\binom{n+k}{k}=\\binom{n+m+1}{m},n 是整数\\qquad \\qquad \\qquad\\quad \\ \\ \\ \\ 平行求和&amp;&amp;(8)\\\\ \\sum_{k=0}^n\\binom{k}{m}=\\binom{n+1}{m+1},整数 n,m\\ge0\\qquad \\qquad \\qquad\\qquad \\ \\ 上指标求和&amp;&amp;(9)\\\\ \\sum_k\\binom{n}{k}\\binom{m}{s-k}=\\binom{n+m}{s},n 是整数\\qquad\\qquad\\qquad 范德蒙德卷积&amp;&amp;(10) \\end{aligned}}(kn​)=k!(n−k)!n!​,整数0≤k≤n 阶乘展开式(kn​)=(n−kn​),整数n≥0,k是整数对称恒等式(kn​)=kn​(k−1n−1​),整数k​=0 吸收恒等式(mn​)=(mn−1​)+(m−1n−1​),k是整数 加法恒等式(mn​)=(−1)m(mm−n−1​),k是整数上指标反转(mn​)(km​)=(kn​)(m−kn−k​),n,m是整数 三项式版恒等式k∑​(kn​)xkyn−k=(x+y)n,整数n≥0或∣∣∣∣​yx​∣∣∣∣​≤1 二项式定理k&lt;=m∑​(kn+k​)=(mn+m+1​),n是整数 平行求和k=0∑n​(mk​)=(m+1n+1​),整数n,m≥0 上指标求和k∑​(kn​)(s−km​)=(sn+m​),n是整数范德蒙德卷积​​(1)(2)(3)(4)(5)(6)(7)(8)(9)(10)​​ ","link":"https://ganytx.github.io/post/ju-ti-shu-xue-bi-ji/"}]}